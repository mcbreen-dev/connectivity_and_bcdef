# Connectivity_and_bcdef (Developer Guide)

This document explains how the project is structured and how bc_define's
connectivity + BC generation works internally. It is intended for developers extending or maintaining the code.

## Repository layout
- `BC_define/`    All C++ sources, headers, and scripts for the tools.
- `build/`        Top-level CMake build output.
- `docs/`         User/developer documentation and algorithm notes.
- `macos/`        macOS-specific Makefile, IO bench scripts, and expected outputs.
- `linux/`        Linux-specific Makefile, IO bench scripts, and expected outputs.
- `meshes/`       Test meshes and bcdef inputs.
- `test/`         Test scripts and working files.

A module map is kept in `docs/module_map.md`.

## Build system
Two build paths are supported:

CMake (top-level):
```
cmake -S . -B build
cmake --build build
```

Linux (system deps + CMake):
```
sudo apt-get update
sudo apt-get install -y libhdf5-dev libcgns-dev
rm -rf build
cmake -S . -B build -DAUTO_DEPS=OFF
cmake --build build
```

Makefile (inside `BC_define/`):
```
make -C BC_define -f ../macos/BC_define.Makefile
```

Linux Makefile:
```
make -C BC_define -f ../linux/BC_define.Makefile CGNS_INC=/path/include CGNS_LIB=/path/lib
```

Notes:
- If CGNS is not found, CMake can auto-fetch pinned CGNS + HDF5 (AUTO_DEPS=ON).
  This requires network access during configure.
- Set `-DAUTO_DEPS=OFF` and provide CGNS via `CGNS_INCLUDE_DIR`/`CGNS_LIBRARY`
  or a `cgns` CMake package to use a system install.
- AUTO_DEPS applies to CMake only; the Makefile expects CGNS/HDF5 installed.
- `BC_define/Makefile` is a stub that points you to the OS-specific Makefile.
- `BC_define/include/k_values.hpp` is generated by
  `BC_define/scripts/compute_k_values.sh` and consumed by the Makefile.
- CMake uses the pre-generated `k_values.hpp` and does not re-run the script.

## Entry points
- `BC_define/src/bc_define_main.cpp` provides the CLI and execution flow.
- `BC_define/src/bc_dump.cpp` is a read-only CGNS inspector for output checks.

## bc_define data flow
High-level path (CGNS):
1. Parse CLI flags, open mesh in modify mode.
2. Optional `--overwrite`: delete `ZoneBC_t` and `ZoneGridConnectivity_t`.
3. Run `ConnectivityDetector::run(...)` to detect 1-to-1 connections and
   boundary patches.
4. Parse `bcdef.input` into a per-zone/face map (strict conflict checks).
5. Write boundary conditions into CGNS (families + BC_t nodes).
6. Optional `--overwrite`: prune unused `Family_t` nodes.

High-level path (Plot3D):
1. Read `.x` into `Plot3DZone` blocks.
2. Run `ConnectivityDetector::run_plot3d(...)`.
3. Parse `bcdef.input` and build BC entries.
4. Write `1to1s` and `bcs` into the working directory.

## Connectivity executable design
Connectivity is split across modules for clarity:

1) Face extraction (`connectivity_face_build.cpp`)
- Build per-face grids and per-cell face centers.
- For CGNS, the algorithm chooses between:
  - Volume read: read all coordinates once, then compute face centers.
  - Face-plane read: read only the face planes.
- The heuristic uses `K2D`, `K3D`, and `MEM_CAP_BYTES` from
  `include/k_values.hpp`.

2) Face metadata (`build_face_summaries`)
- Computes per-face centroid, bounds, and (when available) a face normal.

3) Hashing + candidate generation (`connectivity_hash.cpp`)
- Build a per-face hash table keyed by quantized cell coordinates.
- Bucket faces by bounds to generate candidate face pairs.

4) Pair verification (`connectivity_verify.cpp`)
- For each candidate pair:
  - Try to infer a UV mapping using a few matched samples.
  - If mapping is valid, validate the face mapping directly.
  - Otherwise fall back to nearest-neighbor matching.
- Verification is parallelized across face pairs (thread pool). Results are
  sorted for deterministic output.

5) Patch coalescing + transform resolution (`connectivity_verify.cpp`)
- Convert matched face cells into full-face or sub-face patches.
- Compute CGNS transforms (including sign and permutation).
- Emit `ConnPatch` objects and boundary patch records.

## Boundary condition application
- `bcdef.input` format is parsed by `bc_define_bcspec.cpp`.
- Zone indices are 1-based, faces use `i-/i+/j-/j+/k-/k+`.
- **Strict policy**: overlapping user BCs on the same face is an error.
- `--autowall`/`--autofarfield` only fill boundaries that remain unassigned
  after considering existing BCs.

## Plot3D outputs
Two flat text files are emitted in the current directory:

`1to1s` columns:
```
recv_zone donor_zone
r_i1 r_j1 r_k1 r_i2 r_j2 r_k2
d_i1 d_j1 d_k1 d_i2 d_j2 d_k2
t1 t2 t3
```

`bcs` columns:
```
zone family i1 j1 k1 i2 j2 k2
```

Both use 1-based inclusive ranges.

## Logging and errors
- All tools write `bc_define.log` or `bc_dump.log` alongside the mesh.
- Runtime errors throw `std::runtime_error` and are converted to a single-line
  fatal message in the CLI.

## Tests
CGNS:
```
./test/runtests_cgns.sh
```
Plot3D:
```
./test/runtests_p3d.sh
```

Expected outputs:
- `macos/expected/tests_correct_output_cgns`
- `macos/expected/tests_correct_output_plot3d`
- `linux/expected/` (generate by running tests on Linux)

## Notes for extension
- New BC types should be added in `bc_define_bcspec.cpp` and mapped to CGNS
  enums.
- Connectivity logic assumes 1-to-1 face matches; nonconforming interfaces
  would require a different verification path.
- Plot3D reading is isolated to `plot3d_io.cpp`; file format changes should
  be implemented there.
