/*─────────────────────────────────────────────────────────────
  File: src/bc_define_plot3d.cpp
  Plot3D path and outputs
─────────────────────────────────────────────────────────────*/
#include "bc_define_internal.hpp"

#include <fstream>

namespace fs::bc {

void write_plot3d_1to1s(const std::string& path,
                        const std::vector<fs::Plot3DZone>& zones,
                        const std::vector<fs::ConnPatch>& conns)
{
    std::ofstream out(path);
    if (!out)
        throw std::runtime_error("Could not open output file: " + path);

    out << "# 1to1s generated by bc_define\n";
    out << "# zones " << zones.size() << "\n";
    for (const auto& z : zones) {
        out << "# zone " << z.idx << " " << z.ni() << " " << z.nj() << " " << z.nk() << "\n";
    }
    out << "# columns: recv_zone donor_zone "
           "r_i1 r_j1 r_k1 r_i2 r_j2 r_k2 "
           "d_i1 d_j1 d_k1 d_i2 d_j2 d_k2 t1 t2 t3\n";

    for (const auto& cp : conns) {
        out << cp.recvZone << " " << cp.donorZone << " "
            << cp.recvRange.begin[0] << " " << cp.recvRange.begin[1] << " " << cp.recvRange.begin[2] << " "
            << cp.recvRange.end[0] << " " << cp.recvRange.end[1] << " " << cp.recvRange.end[2] << " "
            << cp.donorRange.begin[0] << " " << cp.donorRange.begin[1] << " " << cp.donorRange.begin[2] << " "
            << cp.donorRange.end[0] << " " << cp.donorRange.end[1] << " " << cp.donorRange.end[2] << " "
            << cp.transform[0] << " " << cp.transform[1] << " " << cp.transform[2] << "\n";
    }
}

std::vector<Plot3DBcEntry> build_plot3d_bcs(
    const std::vector<fs::Plot3DZone>& zones,
    const std::vector<fs::BoundaryPatch>& patches,
    const std::unordered_map<ZoneFaceKey, BCSpec, ZoneFaceKeyHash>& specs,
    bool autowall,
    bool autofarfield)
{
    std::unordered_map<int, std::vector<Plot3DBcEntry>> by_zone;
    std::vector<Plot3DBcEntry> output;

    for (const auto& patch : patches) {
        ZoneFaceKey key{patch.zone, patch.face};
        auto it = specs.find(key);
        const BCSpec* spec = nullptr;
        BCSpec auto_spec{};

        if (it == specs.end()) {
            if (!(autowall || autofarfield))
                continue;
            if (autowall) {
                auto_spec.family = "wall";
                auto_spec.type = CGNS_ENUMV(BCWall);
            } else {
                auto_spec.family = "farfield";
                auto_spec.type = CGNS_ENUMV(BCFarfield);
            }
            spec = &auto_spec;
        } else {
            spec = &it->second;
        }

        const fs::Plot3DZone& zone = zones[static_cast<size_t>(patch.zone - 1)];
        fs::PointRange face_range = face_center_range(zone, patch.face,
                                                      patch.vtxBegin, patch.vtxEnd);
        std::array<long long, 6> new_range = {
            face_range.begin[0], face_range.begin[1], face_range.begin[2],
            face_range.end[0], face_range.end[1], face_range.end[2]
        };

        bool user_spec = (it != specs.end());
        bool overlap_skip = false;
        auto& existing_list = by_zone[patch.zone];
        for (const auto& existing : existing_list) {
            if (existing.face != patch.face)
                continue;
            std::array<long long, 6> overlap{};
            if (!range_overlap(existing.range, new_range, overlap))
                continue;

            bool same_bc = (existing.family == spec->family);
            bool exact = ranges_equal(existing.range, new_range);

            if (user_spec) {
                if (same_bc && exact) {
                    overlap_skip = true;
                    break;
                }
                throw std::runtime_error(
                    "Overlapping BCs in zone " + std::to_string(patch.zone) +
                    " face " + fs::facedir_to_string(patch.face) +
                    ". Existing: " + existing.family +
                    " range " + range_to_string(existing.range) +
                    ", New: " + spec->family +
                    " range " + range_to_string(new_range) +
                    ", Overlap: " + range_to_string(overlap));
            } else {
                overlap_skip = true;
                break;
            }
        }
        if (overlap_skip)
            continue;

        Plot3DBcEntry entry;
        entry.zone = patch.zone;
        entry.face = patch.face;
        entry.family = spec->family;
        entry.range = new_range;
        existing_list.push_back(entry);
        output.push_back(entry);
    }

    return output;
}

void write_plot3d_bcs(const std::string& path,
                      const std::vector<fs::Plot3DZone>& zones,
                      const std::vector<Plot3DBcEntry>& bcs)
{
    std::ofstream out(path);
    if (!out)
        throw std::runtime_error("Could not open output file: " + path);

    out << "# bcs generated by bc_define\n";
    out << "# zones " << zones.size() << "\n";
    for (const auto& z : zones) {
        out << "# zone " << z.idx << " " << z.ni() << " " << z.nj() << " " << z.nk() << "\n";
    }
    out << "# columns: zone family i1 j1 k1 i2 j2 k2\n";

    for (const auto& bc : bcs) {
        out << bc.zone << " " << bc.family << " "
            << bc.range[0] << " " << bc.range[1] << " " << bc.range[2] << " "
            << bc.range[3] << " " << bc.range[4] << " " << bc.range[5] << "\n";
    }
}

} // namespace fs::bc
