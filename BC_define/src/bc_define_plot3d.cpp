/*─────────────────────────────────────────────────────────────
  File: src/bc_define_plot3d.cpp
  Plot3D path and outputs
─────────────────────────────────────────────────────────────
  This file implements the Plot3D (“.x”) output path for bc_define.

  Unlike the CGNS path (which writes BC_t / Family_t nodes into a CGNS
  file), the Plot3D path writes plain-text sidecar files that describe:

    1) 1-to-1 block connectivity patches ("1to1s")
    2) boundary-condition patches ("bcs")

  These text outputs are intended to be consumed by downstream Plot3D
  tooling / solvers that expect connectivity and BC metadata outside the
  mesh file.

  Output files
  ────────────
  write_plot3d_1to1s(path, zones, conns):
    - Writes a header that records zone dimensions.
    - Writes one line per ConnPatch with explicit receiver/donor ranges
      and the CGNS-style signed-permutation Transform vector (t1,t2,t3).

  build_plot3d_bcs(zones, patches, specs, autowall, autofarfield):
    - Converts unmatched boundary patches (BoundaryPatch) into Plot3DBcEntry.
    - Applies user BC specs when present (specs[ZoneFaceKey]).
    - Optionally assigns automatic "wall" or "farfield" to unspecified faces.
    - Enforces a conservative overlap rule:
        * user-specified overlaps are an error unless the overlap is an
          exact duplicate of the same family (idempotent re-runs).
        * auto-assigned BCs are skipped if they overlap any existing entry
          on that face (avoid clobbering explicit/user data).

  write_plot3d_bcs(path, zones, bcs):
    - Writes a header mirroring the zone dimension table.
    - Writes one line per Plot3DBcEntry: zone, family, and IJK range.

  Indexing conventions
  ───────────────────
  - Zone IDs in these files are 1-based (matching Plot3DZone.idx and the
    rest of the toolchain’s public output).
  - BC ranges are expressed in *cell-center* index space (not vertices).
    For structured grids this means varying indices span 1..(N-1).
    face_center_range() performs the vertex→cell conversion.

  Transform convention
  ───────────────────
  ConnPatch::transform uses the CGNS/SIDS transform encoding:
    - Entries are in {0, ±1, ±2, ±3}
    - Magnitude selects donor axis (1=I, 2=J, 3=K)
    - Sign selects direction along that donor axis
    - 2D interfaces may use 0 for the collapsed axis (typically K)

  This file contains no CGNS I/O and is deliberately “dumb” about the
  mesh beyond zone dimensions and index ranges; validation and matching
  happen earlier in the pipeline.
─────────────────────────────────────────────────────────────*/
#include "bc_define_internal.hpp"

#include <fstream>

namespace fs::bc {

/*=====================================================================
  write_plot3d_1to1s

  Write Plot3D connectivity (“1to1s”) as a human-readable text file.

  Format:
    - Leading comment block describing the generator and zone dimensions.
    - One row per ConnPatch:
        recv_zone donor_zone
        r_i1 r_j1 r_k1 r_i2 r_j2 r_k2
        d_i1 d_j1 d_k1 d_i2 d_j2 d_k2
        t1 t2 t3

  Notes:
    - ConnPatch is expected to carry explicit ranges.
    - Ranges and zone IDs are emitted exactly as stored (1-based IJK).
=====================================================================*/
void write_plot3d_1to1s(const std::string& path,
                        const std::vector<fs::Plot3DZone>& zones,
                        const std::vector<fs::ConnPatch>& conns)
{
    std::ofstream out(path);
    if (!out)
        throw std::runtime_error("Could not open output file: " + path);

    /* Header: provenance and zone table for easier debugging. */
    out << "# 1to1s generated by bc_define\n";
    out << "# zones " << zones.size() << "\n";
    for (const auto& z : zones) {
        out << "# zone " << z.idx << " " << z.ni() << " " << z.nj() << " " << z.nk() << "\n";
    }

    /* Column legend (kept in-sync with the emitted row order below). */
    out << "# columns: recv_zone donor_zone "
           "r_i1 r_j1 r_k1 r_i2 r_j2 r_k2 "
           "d_i1 d_j1 d_k1 d_i2 d_j2 d_k2 t1 t2 t3\n";

    /* Emit one connectivity record per patch. */
    for (const auto& cp : conns) {
        out << cp.recvZone << " " << cp.donorZone << " "
            << cp.recvRange.begin[0] << " " << cp.recvRange.begin[1] << " " << cp.recvRange.begin[2] << " "
            << cp.recvRange.end[0] << " " << cp.recvRange.end[1] << " " << cp.recvRange.end[2] << " "
            << cp.donorRange.begin[0] << " " << cp.donorRange.begin[1] << " " << cp.donorRange.begin[2] << " "
            << cp.donorRange.end[0] << " " << cp.donorRange.end[1] << " " << cp.donorRange.end[2] << " "
            << cp.transform[0] << " " << cp.transform[1] << " " << cp.transform[2] << "\n";
    }
}

/*=====================================================================
  build_plot3d_bcs

  Convert boundary patches into Plot3D BC entries.

  Inputs:
    - zones   : Plot3D blocks (zone index == zone id - 1)
    - patches : BoundaryPatch list produced by connectivity resolution
    - specs   : explicit user BC specs keyed by (zone, face)
    - autowall/autofarfield:
        if a patch has no explicit user spec:
          * if autowall  -> assign family "wall" / BCWall
          * else if autofarfield -> assign family "farfield" / BCFarfield
          * else -> skip the patch (no BC emitted)

  Overlap policy (per zone, per face):
    - If the user explicitly specified the BC (specs hit):
        * exact duplicate of same family is ignored (idempotent)
        * any other overlap triggers an error (ambiguous BC assignment)
    - If the BC is auto-assigned:
        * any overlap with an existing BC on that face causes the auto
          patch to be skipped (prefer existing/user data)

  Output:
    - Returns a flat list of Plot3DBcEntry, and internally tracks what has
      been emitted per zone for overlap checking.
=====================================================================*/
std::vector<Plot3DBcEntry> build_plot3d_bcs(
    const std::vector<fs::Plot3DZone>& zones,
    const std::vector<fs::BoundaryPatch>& patches,
    const std::unordered_map<ZoneFaceKey, BCSpec, ZoneFaceKeyHash>& specs,
    bool autowall,
    bool autofarfield)
{
    /* Track already-produced entries to prevent overlaps within this run. */
    std::unordered_map<int, std::vector<Plot3DBcEntry>> by_zone;
    std::vector<Plot3DBcEntry> output;

    for (const auto& patch : patches) {
        ZoneFaceKey key{patch.zone, patch.face};
        auto it = specs.find(key);
        const BCSpec* spec = nullptr;
        BCSpec auto_spec{};

        /* Select the BC family/type either from user config or auto rules. */
        if (it == specs.end()) {
            if (!(autowall || autofarfield))
                continue;
            if (autowall) {
                auto_spec.family = "wall";
                auto_spec.type = CGNS_ENUMV(BCWall);
            } else {
                auto_spec.family = "farfield";
                auto_spec.type = CGNS_ENUMV(BCFarfield);
            }
            spec = &auto_spec;
        } else {
            spec = &it->second;
        }

        /* Compute the patch range in cell-center index space. */
        const fs::Plot3DZone& zone = zones[static_cast<size_t>(patch.zone - 1)];
        fs::PointRange face_range = face_center_range(zone, patch.face,
                                                      patch.vtxBegin, patch.vtxEnd);
        std::array<long long, 6> new_range = {
            face_range.begin[0], face_range.begin[1], face_range.begin[2],
            face_range.end[0], face_range.end[1], face_range.end[2]
        };

        bool user_spec = (it != specs.end());
        bool overlap_skip = false;

        /* Overlap detection against entries already accumulated for this zone. */
        auto& existing_list = by_zone[patch.zone];
        for (const auto& existing : existing_list) {
            if (existing.face != patch.face)
                continue;
            std::array<long long, 6> overlap{};
            if (!range_overlap(existing.range, new_range, overlap))
                continue;

            bool same_bc = (existing.family == spec->family);
            bool exact = ranges_equal(existing.range, new_range);

            if (user_spec) {

                /* User config must be unambiguous: overlap is only ok if identical. */
                if (same_bc && exact) {
                    overlap_skip = true;
                    break;
                }
                throw std::runtime_error(
                    "Overlapping BCs in zone " + std::to_string(patch.zone) +
                    " face " + fs::facedir_to_string(patch.face) +
                    ". Existing: " + existing.family +
                    " range " + range_to_string(existing.range) +
                    ", New: " + spec->family +
                    " range " + range_to_string(new_range) +
                    ", Overlap: " + range_to_string(overlap));
            } else {

                /* Auto BC: any overlap means “hands off”. */
                overlap_skip = true;
                break;
            }
        }
        if (overlap_skip)
            continue;

        /* Record the new BC entry. */
        Plot3DBcEntry entry;
        entry.zone = patch.zone;
        entry.face = patch.face;
        entry.family = spec->family;
        entry.range = new_range;

        existing_list.push_back(entry);
        output.push_back(entry);
    }

    return output;
}

/*=====================================================================
  write_plot3d_bcs

  Write Plot3D boundary conditions (“bcs”) as a text file.

  Format:
    - Leading comment block and zone dimension table.
    - One row per Plot3DBcEntry:
        zone family i1 j1 k1 i2 j2 k2

  Notes:
    - family is a free-form string (typically a small, stable label like
      "wall", "farfield", "inflow", ...).
    - Ranges are cell-center indices (1..N-1 on varying axes).
=====================================================================*/
void write_plot3d_bcs(const std::string& path,
                      const std::vector<fs::Plot3DZone>& zones,
                      const std::vector<Plot3DBcEntry>& bcs)
{
    std::ofstream out(path);
    if (!out)
        throw std::runtime_error("Could not open output file: " + path);

    out << "# bcs generated by bc_define\n";
    out << "# zones " << zones.size() << "\n";
    for (const auto& z : zones) {
        out << "# zone " << z.idx << " " << z.ni() << " " << z.nj() << " " << z.nk() << "\n";
    }
    out << "# columns: zone family i1 j1 k1 i2 j2 k2\n";

    for (const auto& bc : bcs) {
        out << bc.zone << " " << bc.family << " "
            << bc.range[0] << " " << bc.range[1] << " " << bc.range[2] << " "
            << bc.range[3] << " " << bc.range[4] << " " << bc.range[5] << "\n";
    }
}

} // namespace fs::bc
